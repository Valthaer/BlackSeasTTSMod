-- Global number of paces moved
g_knots_movement = 3
g_fleet_selected = ''

-- Updates the global that manages the number of paces moved by the other functions, and updates the UI
function slider_knots_changed(player, value, id)
    print_debug('value of slider knots: ' .. value) 
    g_knots_movement = value

    -- It's undocumented, but changing the value of the button does not update
    -- the button_move_forward
    -- Instead we have to change the undocumented text attribute, but we still
    -- change the value because it's the proper thing
    UI.setAttribute('button_move_forward', 'text', 'Move ' .. g_knots_movement .. ' knots')
    UI.setValue('button_move_forward', 'Move ' .. g_knots_movement .. ' knots')
    
    -- Make it consistent for all players
    Wait.frames(function()
        UI.setAttribute('slider_knots', 'value', value)
    end, 1)

    -- Update any gizmo
    --draw_gizmo_future_movements(player.getSelectedObjects())
end

function move_forward(player, value, id)
    print_debug('player ' .. player.steam_name)
    print_debug('player move forward ' .. g_knots_movement)
    local objs = filter_ships(player.getSelectedObjects())
    if tlen(objs) < 1 then
        print_error(player.steam_name ..' is trying to move 3 knots, but (s)he has no object selected, ignoring')
    return
    end

    local move = {}
    for _,obj in ipairs(objs) do
        local initial_transform = calculate_transform(obj)
        local moved_knots = move_base(obj, g_knots_movement, true)
        local new_transform = calculate_transform(obj)
        add_transform_to_move(move, obj.getName(), initial_transform, new_transform)

        print_info(player.steam_name .. ' is moving ' .. obj.getName() .. ' ' .. moved_knots .. ' knots forward')
    end
    --push_to_history_stack(move)

    -- Moving the bases should imply update the gizmos
    --draw_gizmo_future_movements(player.getSelectedObjects())
end

function on_undo_move(player, value, id)
    --go_back_history_stack()
end

function on_redo_move(player, value, id)
    --go_forward_history_stack()
end

-- Given a list of objects in a table, returns another table with ONLY
-- those who start with 'base', ignoring the keys
function filter_ships(list)
    local filtered = {}
    for _,obj in ipairs(list) do
        local name = obj.getName()
        print_debug('ship name in filter: ' .. name)
        if g_ships[name] ~= nil or str_starts_with(obj.getName(), 'Ship') then
            table.insert(filtered, obj)
        end
    end
    return filtered
end

function deploy_fleet(player, value, id)
    local status = UI.getAttribute('panel_bs_fleet_selection', 'active')
    if status == 'True' then
        -- Ignore, the user is clicking despite the menu already being there
        return
    end

    --local book, army = get_initial_army()
    print_debug('Selected fleet is ' .. g_fleet_selected)    

    --update_book_menu(1)
    on_next_frame(function()        
        UI.setAttribute('panel_bs_fleet_selection_bg', 'active', true)
        UI.setAttribute('panel_bs_fleet_selection_bg', 'visibility', player.color)
        UI.setAttribute('panel_bs_fleet_selection', 'active', true)
        UI.setAttribute('panel_bs_fleet_selection', 'visibility', player.color)
        UI.setAttribute('button_deploy_fleet', 'interactable', false)
      --  on_next_frame(function()
            --update_armies_menu(book, 1)
        --    on_next_frame(function()
                --update_authors_text(army)
          --      on_next_frame(function()
                    --update_player_color_menu(g_color_spawn_army_selected == 'Red')
            --    end)
        --    end)
    --    end)
    end)
end
