-- Global number of paces moved
g_knots_movement = 3

-- Updates the global that manages the number of paces moved by the other functions, and updates the UI
function slider_knots_changed(player, value, id)
    print_debug('value of slider knots: ' .. value) 
    g_knots_movement = value

    -- It's undocumented, but changing the value of the button does not update
    -- the button_move_forward
    -- Instead we have to change the undocumented text attribute, but we still
    -- change the value because it's the proper thing
    UI.setAttribute('button_move_forward', 'text', 'Move ' .. g_knots_movement .. ' knots')
    UI.setValue('button_move_forward', 'Move ' .. g_knots_movement .. ' knots')
    
    -- Make it consistent for all players
    Wait.frames(function()
        UI.setAttribute('slider_knots', 'value', value)
    end, 1)

    -- Update any gizmo
    --draw_gizmo_future_movements(player.getSelectedObjects())
end

function move_forward(player, value, id)
    print_debug('player ' .. player.steam_name)
    print_debug('player move forward ' .. g_knots_movement)
    local objs = filter_ships(player.getSelectedObjects())
    if tlen(objs) < 1 then
        print_error(player.steam_name ..' is trying to move 3 knots, but (s)he has no object selected, ignoring')
    return
    end

    local move = {}
    for _,obj in ipairs(objs) do
        local initial_transform = calculate_transform(obj)
        local moved_knots = move_base(obj, g_knots_movement, true)
        local new_transform = calculate_transform(obj)
        add_transform_to_move(move, obj.getName(), initial_transform, new_transform)

        print_info(player.steam_name .. ' is moving ' .. obj.getName() .. ' ' .. moved_knots .. ' knots forward')
    end
    --push_to_history_stack(move)

    -- Moving the bases should imply update the gizmos
    --draw_gizmo_future_movements(player.getSelectedObjects())
end

function on_undo_move(player, value, id)
    --go_back_history_stack()
end

function on_redo_move(player, value, id)
    --go_forward_history_stack()
end

-- Given a list of objects in a table, returns another table with ONLY
-- those who start with 'base', ignoring the keys
function filter_ships(list)
    local filtered = {}
    for _,obj in ipairs(list) do
        local name = obj.getName()
        print_debug('ship name in filter: ' .. name)
        if g_ships[name] ~= nil or str_starts_with(obj.getName(), 'Ship') then
            table.insert(filtered, obj)
        end
    end
    return filtered
end
